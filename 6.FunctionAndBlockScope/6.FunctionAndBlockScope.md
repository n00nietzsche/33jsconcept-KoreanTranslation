## 들어가기 전에
- 이 포스팅은 https://github.com/leonardomso/33-js-concepts 에 있는 포스팅들을 번역한 것입니다. 오역이나 의역이 있을 수 있습니다. 지적해주시면 확인 후 바로 정정하겠습니다.

- original source of this posting is from https://css-tricks.com/javascript-scope-closures/ If the original author requests deletion, it will be deleted immediately.

- Translated by Jake Seo (서진규)

	- https://velog.io/@jakeseo_me
	- https://github.com/n00nietzsche

## 스코프(Scope)

자바스크립트에서 스코프는 어떤 변수에 접근할 수 있는지를 정의합니다. 일반적으로 2가지의 스코프가 존재합니다. 전역 스코프와 지역 스코프가 존재하죠.

### 전역 스코프(Global Scope)

만일 만일 변수가 모든 함수에 속하지 않고 `{}`괄호안에 들어있지도 않다면 우리는 그 변수를 전역 변수라 합니다.
> 사실 Node.js에서의 전역 변수 선언은 약간 다르지만 여기서는 웹 브라우저 내부에서의 자바스크립트만 다룰 것이기 때문에 Node.js에서의 전역변수 선언은 다루지 않습니다.

```javascript
const globalVariable = 'some value'
```

일단 전역 변수를 선언하면, 자바스크립트 코드 어디에서든 불러 쓸 수 있습니다. 심지어 함수 내부에서도요.

```javascript
const hello = 'Hello CSS-Tricks Reader!'

function sayHello () {
	console.log(hello); 
}

console.log(hello); // 'Hello CSS-Tricks Reader!'
sayHello(); // 'Hello CSS-Tricks Reader!'
```

전역 변수에서 변수 선언을 할 수 있더라도, 전역 변수에서는 변수 선언을 하지 않는 것이 권장됩니다. 왜냐하면 두개 혹은 그 이상의 변수들이 같은 이름을 가지게 되어 네이밍 충돌(naming collisions)이 발생할 확률이 있기 때문입니다. 

만일 우리가 `const` 또는 `let` 키워드로 같은 이름의 변수를 선언하게 된다면 우리는 에러를 보게 될 것입니다.
```javascript
// Don't do this!
let thing = 'something'
let thing = 'something else' // Error, thing has already decleared
```

만일 우리가 `var` 키워드로 변수 선언을 한다면, 우리의 두번째 변수가 첫번째 변수를 덮어씁니다. 이러한 코드를 만들게 되면 디버그 하기가 매우 힘드니 우리는 절대로 이러한 코드를 작성하면 안됩니다.

```javascript
// Don't do this!
var thing = 'something'
var thing = 'something else' // perhaps somewhere totally different in your code
console.log(thing) // 'something else'
```
우리는 전역변수 사용을 자제해야 합니다.
지역변수 사용을 지향합시다.

### 지역 스코프(Local Scope)

코드 내 특정 구역에서만 사용할 수 있는 변수를 지역변수라고 합니다.
자바스크립트에서는 두가지 종류의 지역 변수가 있습니다.

1. 함수 스코프 지역 변수
2. 블록 스코프 지역 변수 

함수 스코프 지역변수부터 알아봅시다.

### 함수 스코프(Function Scope)

함수 내에서 변수를 선언했을 때, 우리는 함수 안에서만 이 변수에 접근할 수 있습니다. 우리가 함수 밖으로 나오게 된 이후에는 함수 내부에 있는 변수에 접근할 수 없습니다.

아래 `sayHello`함수 안에 들어있는 `hello`라는 변수의 예제를 봅시다.
```javascript
function sayHello () {
	const hello = 'Hello CSS-Tricks Reader!';
    console.log(hello);
}

sayHello(); // 'Hello CSS-Tricks Reader!'
console.log(hello) // Error, hello is not defined
```

### 블록 스코프(Block Scope)
우리가 변수를 `{}` 괄호 안에 `const`나 `let`키워드로 선언했을 때, 우리는 `{}`괄호 안에서만 이 변수에 접근할 수 있습니다.

아래 예제에서, `hello`는 `{}`괄호 안의 스코프를 갖습니다.

```javascript
{
	const hello = 'Hello CSS-Tricks Reader!'
    console.log(hello) // 'Hello CSS-Tricks Reader!'
}

console.log(hello) // Error, hello is not defined
```

블록 스코프는 함수 스코프의 부분집합입니다. 함수는 `{}`괄호로 작성되어야 하기 때문이죠. 물론 화살표 함수로 즉시 리턴하면 `{}`없이 함수를 만들 수도 있습니다. 그렇지 않은 경우에는 모두 `{}`괄호로 작성되어야 하죠.

### 함수 호이스팅과 스코프
(주: 호이스팅은 '끌어올리다' 라는 의미를 가지고 있습니다.)

`function` 키워드와 함께 선언된 함수들은 항상 현재 스코프의 가장 위로 호이스팅됩니다.
그래서 다음 코드의 결과는 같습니다.

```javascript
// 이 코드의 결과는 아래의 코드와 같습니다.
sayHello();
function sayHello () {
	console.log('Hello CSS-Tricks Reader!');
}

// 이 코드의 결과는 위의 코드의 결과와 같습니다.
function sayHello() {
	console.log('Hello CSS-Tricks Reader!'); 
}
sayHello();
```

함수 표현식으로 작성된 함수들은 현재 스코프의 가장 위로 **호이스팅 되지 않습니다.**

```javascript
sayHello(); // Error, sayHello is not defined
const sayHello = function () {
	console.log('Hello CSS-Tricks Reader!');  
}
```

이러한 두가지 방법 때문에 함수 호이스팅은 헷갈릴 수 있습니다. 그리고 사용되어선 안됩니다. 항상 함수는 사용 전에 미리 선언하세요.

### 함수는 각자의 스코프에 접근할 수 없다

함수를 각각 선언했을 때, 함수는 다른 함수의 스코프에 접근할 권한을 갖고 있지 않습니다. 심지어 함수 내에서 다른 함수를 불러오더라도 스코프는 사용할 수 없습니다.

아래 예제에서, `second`는 `firstFunctionVariable`에 접근할 권한이 없습니다.

```javascript
function first () {
	const firstFunctionVariable = `I'm part of first`;
}

function second () {
	first();
	console.log(firstFunctionVariable); // Error, firstFunctionVariable is not defined
}
```

### 
