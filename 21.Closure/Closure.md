# 들어가기 전에

- 이 포스팅은 https://javascript.info/closure 에 있는 포스팅들을 번역한 것입니다. 오역이나 의역이 있을 수 있습니다. 지적해주시면 확인 후 바로 정정하겠습니다.

- original source of this posting is from https://javascript.info/closure If the original author requests deletion, it will be deleted immediately.

- Translated by Jake Seo (서진규)

	- https://velog.io/@jakeseo_me
	- https://github.com/n00nietzsche

> 자바스크립트 개발자라면 알아야 할 33가지 개념 #21 자바스크립트 : 클로져

# 클로져

자바스크립트는 매우 함수지향적인 언어입니다. 자바스크립트는 우리에게 많은 자유를 줍니다. 함수는 동적으로 만들어질 수 있습니다. 다른 변수에 복사될 수도 있고, 다른 함수에 인자로 넘겨질 수도 있고 완전히 다른 장소에서 나중에 호출될 수도 있습니다.

우리는 함수가 함수 외부에 있는 변수에 접근할 수 있다는 것을 알고 있습니다. 그리고 이러한 특성은 자주 사용됩니다.

하지만 외부의 변수가 변경될 때, 무슨 일이 일어날까요? 함수는 가장 최근 값을 갖을까요? 또는 함수가 만들어질 때 존재했던 값을 가질까요?

또, 코드에서 함수가 다른 위치로 이동할 때, 그리고 거기에서 호출됐을 때, 무슨 일이 일어날까요? 함수는 새로운 위치의 외부 변수에 접근 가능할까요?

다른 언어들은 다르게 동작합니다. 이 챕터에서 우리는 자바스크립트는 어떻게 동작하는지에 대해 다뤄보겠습니다.

## 몇가지 질문

두가지 상황을 고려해보는 것으로 시작해봅시다. 그리고 여러분이 다음 질문에 대답하고 미래에는 더 어려운 질문에도 대답할 수 있도록 내부 동작을 하나하나 공부해봅시다.

1. 함수 `sayHi`는 외부 변수 `name`을 사용합니다. 함수가 동작할 때, 어떤 값을 사용할까요?

```js
let name = "John";

function sayHi() {
  alert("Hi, " + name);
}

name = "Pete";

sayHi(); // what will it show: "John" or "Pete"?
```

이러한 상황은 브라우저단 그리고 서버단 개발에서 흔히 있는 상황입니다. 함수는 먼저 생성된 뒤에 나중에 실행되도록 예정되어있습니다. 예를 들면 유저의 액션 또는 네트워크 요청 이후입니다.

그래서, 문제는 : 이 함수가 최신에 변경된 값을 가져올까요?

2. 함수 `makeWorker`는 다른 함수를 만들어내고 반환합니다. 새로운 함수는 다른 어딘가에서 불려질 수 있습니다. 이 함수는 어떤 외부 변수에 대한 접근 권한을 갖고 있을까요. 이 함수가 만들어 진 곳? 또는 함수가 호출된 곳? 또는 두 곳 모두?

## 어휘적인(Lexical) 환경

어떤 일이 일어나는지 이해하기 위해서, "변수"란 것이 무엇인지에 대해 먼저 논의해봅시다.

자바스크립트에서, 모든 동작하는 함수 코드블럭 `{...}`과 스크립트 전체는 내부적인 (숨겨진) 연관된 오브젝트를 *어휘적인(Lexical) 환경*으로서 갖고 있습니다.

어휘적 환경 오브젝트는 두가지 부분을 갖고 있습니다 :

1. *환경 기록(Environment Record)* - 모든 지역 변수를 프로퍼티로 갖고 있는 오브젝트 (그리고 `this`의 값과 같은 다른 정보들도)
2. *외부 어휘 환경(outer lexical environment)* 에 대한 참조, 외부 코드에 관련된 것

**그래서 "변수"는 특별한 내부 오브젝트(환경 기록, Environment Record)의 프로퍼티입니다. "변수를 가져오거나 변경하는 것"은 "그 오브젝트의 프로퍼티를 가져오거나 변경하는 것"을 의미합니다.**

예를 들면, 이 간단한 예제 코드에서는, 단 하나의 어휘적 환경만 지닙니다:

![lexical-env1.png](https://images.velog.io/post-images/jakeseo_me/3cff1870-8674-11e9-9809-ed6e36f2cf44/lexical-env1.png)

이것은 전역 어휘 환경이라고 불리는 것입니다. 전체 스크립트에 연관되어 있습니다.

위의 사진에서, 사각형은 환경 기록(Environment Record, 변수 저장소)을 의미합니다. 그리고 화살이 의미하는 것은 외부 참조입니다. 전역 어휘 환경은 외부 참조를 갖고 있지 않습니다. 그래서 전역 어휘 환경은 `null`을 가리킵니다.

여기 let이 변경될 때, 어떠한 일이 일어나는지에 대한 더 커다란 그림이 있습니다.

![lexical-environment-global-2.png](https://images.velog.io/post-images/jakeseo_me/a69483b0-8674-11e9-94a9-093dca7124f1/lexical-environment-global-2.png)

오른쪽의 사각형들은 전역 어휘 환경이 실행동안 어떻게 변화하는지에 대한 묘사를 하고 있습니다.

1. 스크립트가 시작할 때, 어휘 환경은 비어있습니다.
2. `let phrase` 정의가 나타납니다. 현재 아무런 값도 할당되어 있지 않습니다. 그래서 `undefined`가 저장됩니다.
3. phrase는 값을 할당받습니다.
4. phrase는 값을 바꿉니다.

현재까지는 모든 것들이 간단해보일겁니다. 그렇지 않나요?

요약하자면:

- 변수는 특별한 내부 오브젝트의 프로퍼티입니다. 특별한 내부 오브젝트는 현재 실행중인 블록/함수/스크립트와 연관되어 있습니다.
- 변수들이 작동하는 것은 실제로 그 오브젝트의 프로퍼티들이 작동하는 것입니다.

## 함수 선언

지금까지, 우리는 변수에 대해서만 알아봤습니다. 이제 함수 선언에 대해 알아봅시다.

**`let` 변수와는 다르게, 함수는 완전히 초기화됩니다. 프로그램이 실행되어 함수에 접근할 때 초기화되는 것이 아니라 그 이전에 어휘적 (Lexical) 환경이 만들어질 때 함수는 초기화됩니다.**

최상위 레벨의 함수들은 스크립트가 시작되는 순간에 초기화됩니다.

이것이 우리가 함수가 정의되기 전에 함수 선언을 호출할 수 있는 이유입니다. 

아래의 코드는 어휘적(Lexical) 환경이 시작부터 비어있는 상태가 아니라는 것(non-empty)을 나타냅니다. 아래에서 어휘적(Lexical) 환경은 함수 `say`를 갖고 있습니다. 왜냐하면 `say`는 함수 선언이기 때문입니다. 그리고 이후에 어휘적 환경은 `let`으로 선언된 `phrase`를 갖게 됩니다.

![lexical-environment-global-3.png](https://images.velog.io/post-images/jakeseo_me/59f849e0-8b1c-11e9-953c-41d6fbbdf251/lexical-environment-global-3.png)

## 내부(Inner)와 외부(outer) 어휘(Lexical) 환경

이제 함수가 외부의 변수에 접근할 때 무슨 일이 일어나는지 살펴봅시다.

함수 호출 동안, `say()`는 외부 변수 `phrase`를 사용합니다. 어떤 일이 일어나는지 상세하게 살펴봅시다.

먼저, 함수가 실행될 때, 새로운 함수 어휘 환경이 자동으로 만들어집니다. 모든 함수에 대한 일반적인 규칙입니다. 어휘적 환경은 지역 변수들과 함수 호출 시의 파라미터를 저장하기 위하여 사용됩니다.

예를 들면 `say("John")`의 경우는, 다음 그림처럼 보입니다. (실행을 아래의 그림에서 화살표로 표기된 곳에서 하고 있습니다.)

![lexical-environment-simple.png](https://images.velog.io/post-images/jakeseo_me/744bb570-8b3f-11e9-bd94-1dd655c28c38/lexical-environment-simple.png)

그래서 함수 호출 동안, 우리는 2개의 어휘 환경을 갖고 있습니다: 함수 호출을 위한 내부 어휘 환경과 전역 변수를 위한 외부 어휘 환경을 갖고 있습니다.

- 내부 어휘 환경은 `say`의 현재 실행에 대응됩니다.
- 내부 어휘 환경은 `name`이라는 하나의 프로퍼티(함수 인자)를 갖고 있습니다. 우리는 `say("John")`을 호출하였고, name의 값은 "John"이 됩니다.
- 외부 어휘 환경은 전역 어휘 환경입니다. 외부 어휘 환경은 `phrase` 변수와 함수 그 자체를 갖고 있습니다.

내부 어휘 환경은 외부 어휘 환경에 대한 참조를 갖고 있습니다. 

**코드에서 변수에 접근할 때, 내부 어휘 환경이 먼저 검색됩니다. 그리고 외부 어휘 환경을 검색합니다. 그리고 더욱 외부에 있는 어휘 환경을 거쳐 전역 어휘 환경까지 도달합니다.**

만일 어디에서도 변수가 발견되지 않는다면, strict mode에서는 에러가 표기됩니다. `use strict`표기 없이는, 이전 버전에 대한 호환성을 위하여 정의되지 않은(undefined) 변수를 새로 할당하여 전역 변수를 만들어낼 것입니다.

우리 예제에서 검색 과정이 어떻게 진행되는지 살펴봅시다.

- `say` 내부의 `alert`가 `name`에 접근하길 원할 때, `say` 함수는 함수 어휘 환경 내부에서 `name`이라는 이름을 즉시 찾아봅니다.
- `say`가 `phrase`에 접근하길 원할 때는, `phrase`는 지역 어휘 환경에는 존재하지 않습니다. 그래서 둘러싸는 (enclosing) 어휘 환경의 참조를 따라가고 외부 어휘 환경에서 `phrase`를 찾아냅니다.

![lexical-environment-simple-lookup.png](https://images.velog.io/post-images/jakeseo_me/1795e870-8b47-11e9-9034-95d7d971847a/lexical-environment-simple-lookup.png)

이제 여러분은 챕터에서 처음 나왔던 질문에 대해 답을 할 수 있습니다.

**함수는 현재 외부 변수에 접근이 가능하다; 그러나 가장 가까운 값을 사용한다.**

이러한 일이 발생하는 원인은 상술된 메커니즘 때문입니다. 오래된 변수 값들은 어디에도 저장되지 않습니다. 함수가 오래된 변수 값들을 참조하길 원할 때, 함수는 자기 자신의 어휘 환경 또는 외부 어휘 환경에서 지금 값을 가져옵니다.

그래서 첫번째 질문의 답은 `"Pete"` 였습니다.

```js
let name = "John";

function sayHi() {
  alert("Hi, " + name);
}

name = "Pete"; // (*)

sayHi(); // Pete
```

위의 코드의 흐름은 다음과 같습니다.

1. 전역 어휘 환경은 `name: "John"`을 갖고 있습니다.
2. `(*)`로 표기된 줄에서, 전역 변수가 변경됩니다. 이젠 전역 어휘 환경은 `name: "Pete"`를 갖습니다.
3. `sayHi()`가 실행되고 `name` 변수 값을 외부에서 가져옵니다. `name` 변수는 전역 어휘 환경에서 가지고 오게 되는데, 전역 어휘 환경의 `name`은 `"Pete"`입니다.

