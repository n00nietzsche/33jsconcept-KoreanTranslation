# 들어가기 전에
- 이 포스팅은 https://github.com/leonardomso/33-js-concepts 에 있는 포스팅들을 번역한 것입니다. 오역이나 의역이 있을 수 있습니다. 지적해주시면 확인 후 바로 정정하겠습니다.

- original source of this posting is from https://javascript.info/settimeout-setinterval If the original author requests deletion, it will be deleted immediately.

- Translated by Jake Seo (서진규)

	- https://velog.io/@jakeseo_me
	- https://github.com/n00nietzsche

> 자바스크립트 개발자라면 알아야 할 33가지 개념 #10 스케쥴링: setTimeout과 setInterval

개발을 하다보면, 함수를 당장 실행하지 않고 정확히 몇 초의 딜레이 후에 실행하고 싶을 때가 있을 것입니다. 이것을 "호출 스케쥴링하기(scheduling a call)"라고 합니다. 

이것을 구현하기 위해 두가지 메소드가 존재합니다.
- `setTimeout`은 일정 시간 간격 이후에 함수가 한번 실행됩니다.
- `setInterval`은 일정 시간 간격으로 함수가 주기적으로 실행됩니다.

위의 두 메소드들은 자바스크립트 스펙의 일부가 아닙니다. 하지만 대부분의 환경은 내부적인 스케쥴러를 갖고 있습니다. 그리고 이러한 메소드들을 제공합니다. 구체적으로는, Node.JS와 모든 브라우저에서 제공됩니다.

# setTimeout

문법:
```js
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...);
```

파라미터:
`func|code`
실행을 위한 함수나 문자열입니다. 주로, 함수를 받습니다. 히스토리적인 이유로, 코드의 문자열도 넘겨질수 있지만 권장되지는 않습니다.

`delay`
실행하기 전의 딜레이 입니다. ms단위로 이루어져 있습니다. 1000ms = 1s 입니다. 디폴트 값은 0이 들어있습니다.

`arg1`, `arg2`...
함수에 대한 인자(Arguments)들입니다. (IE9 미만의 버전에서는 지원되지 않습니다.)

예를 들어 1초 후에 `sayHi()`를 호출하는 코드를 작성해봅시다.
```js
function sayHi() {
  alert('Hello');  
}

setTimeout(sayHi, 1000);
```

인자를 줘봅시다.

```js
function sayHi(phrase, who) {
  alert( phrase + ', ' + who);  
}

setTimeout(sayHi, 1000, "Hello", "John"); // Hello, John
```

만일 첫번째 인자에 문자열이 들어온다면, 자바스크립트는 그로부터 함수를 만들어낼 것입니다.

무슨 말이냐면 다음 코드가 동작한다는 것입니다.

```js
setTimeout("alert('Hello')", 1000);
```

하지만 문자열을 사용하는 것은 권장되지 않습니다. 문자열 대신 함수를 사용해주세요. 다음과 같이요.

```js
setTimeout(() => alert('Hello'), 1000);
```

 **함수를 넘겨야 하지만, 실행하진 마세요.** 가끔 풋내기 개발자들이 하는 실수는 함수 뒤에 `()` 괄호를 추가하는 것입니다.
```js
// Wrong!
setTimeout(sayHi(), 1000);
```
 위의 코드는 작동하지 않습니다. 왜냐하면 `setTimeout`은 함수로의 참조를 받아올 것이라 예상했기 때문입니다. 여기 `sayHi()`는 함수를 실행시킵니다 그리고 실행의 결과가 `setTimeout`으로 전달됩니다. 우리가 코딩했던 것들을 살펴봤을 때, `sayHi()`의 결과는 `undefined` (아무것도 리턴하지 않는 함수)입니다. 그러므로 아무것도 스케쥴되지 않습니다.
 
 ## clearTimeout으로 취소하기
 
 `setTimeout`을 호출했을 때, 반환 값으로 우리가 실행을 취소하기 위해 사용할 수 있는 "timer identifier"인 `timerId`를 줍니다.
 
취소하기 위한 문법은 다음과 같습니다.

```js
let timerId = setTimeout(...);
clearTimeout(timerId);
```

아래의 코드에서, 함수를 스케쥴링하고 그 후에 취소합니다(우리의 마음이 바뀌었습니다). 결과로, 아무것도 일어나지 않습니다.

```js
let timerId = setTimeout(() => alert("never happens"), 1000);
alert(timerId); // timer identifier

clearTimeout(timerId);
alert(timerId); // same identifier (취소 이후에도 null이 되진 않습니다.)
```

우리가 `alert` 출력을 통해 알 수 있듯이, 브라우저 내부에서, timer identifier는 숫자입니다. 다른 환경에서는, timer identifier는 다른 것이 될 수 있습니다. 예를 들면, Node.JS는 추가적인 메소드와 함께 timer object를 리턴합니다.

다시 한번 말하지만, 이러한 메소드에 대한 국제적인 스펙이 없습니다. 그래서 괜찮습니다.

브라우저들에 대해서는, HTML5 표준의 [timer section](https://www.w3.org/TR/html5/webappapis.html#timers)에 기술된 것을 참조하세요.

# setInterval

`setInterval` 메소드는 `setTimeout` 과 같은 문법을 갖고 있습니다.

```js
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...);
```

모든 인자들은 같은 의미를 갖습니다. 하지만 `setTimeout`과는 다르게 함수를 한번만 실행하는 것이 아니라 부여된 시간 간격 이후로 주기적으로 실행합니다.

더이상 호출하는 것을 중지하고 싶다면, 우리는 `clearInterval(timerId)`를 호출해야 합니다.

아래의 예제는 2초마다 메시지를 보여줍니다. 5초 후에, 출력이 중지됩니다.

```js
// 2초마다 반복
let timerId = setInterval(() => alert('tick'), 2000);

// 5초 후에 정지
setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);
```

**Chrome/Opera/Safari에서는 Modal windows가 시간을 freeze 합니다.**
IE와 Firefox에서는 `alert/confirm/prompt`를 보여주면서 내부적인 타이머가 계속해서 "ticking"을 하지만 크롬, 오페라 사파리에서는 내부적인 타이머가 "frozen" 상태가 됩니다.

그래서 만일 위의 코드를 돌리고 alert 윈도우를 일정 시간 동안 없애지 않았다면, 그 후에 Firefox/IE는 다음 `alert`가 즉시 보여집니다. (지난 호출에서 2초 경과 후에), 그리고 Chrome/Opera/Safari에서는 2초가 더 지난 후에 보여지게 될 것입니다. (타이머는 `alert`동안에 시간이 가지 않습니다.)

> 역자 주 : 2019.04.23 현재일자 기준 테스트 결과 alert는 js 엔진의 스레드를 멈추지 않습니다. alert 동안에도 시간이 갑니다. 아무래도 과거의 지식인 것 같습니다.

## 재귀적인 setTimeout

무언가 정기적으로 실행시키기 위해서는 두가지 방법이 있습니다.

한가지가 `setInterval`이었고, 두번째가 재귀적인 `setTimeout`입니다. 구현은 다음과 같습니다.

```js
let timerId = setTimeout(function tick() {
  alert('tick');
  timerId = setTimeout(tick, 2000); // (*)
}, 2000);
```

위의 `setTimeout`은 현재 실행중인 것이 끝날 때(`(*)`) 다음 호출을 바로 스케쥴합니다. 

재귀적인 `setTimeout`은 `setInterval`보다 더욱 유연합니다. 이 방법에서는 다음 호출은 아마 때에 따라 다르게 스케쥴 될 것입니다. 현재 실행하던 것의 결과에 따라 달라지겠죠.

이를테면, 우리가 서버에 5초마다 데이터를 물어보는 요청을 보내는 서비스를 작성할 필요가 있는데, 서버에 요청이 너무 많을 때는 계속해서 요청을 보내기 보다는 우리가 주기를 10초, 20초, 40초 정도로 늘리는 것이 바람직합니다.

다음은 의사코드입니다.

```js
let delay = 5000;

let timerId = setTimeout(function request() {
  ...요청 전송...
  
  if(서버 과부하 때문에 요청이 실패한다면...) {
    // 다음 실행까지 인터벌을 좀 늘리자..
    delay *= 2;
  }
  
  timerId = setTimeout(request, delay);
  
}, delay);
```

그리고 우리가 주기적으로 CPU 사용량이 많은 작업(CPU-hungry tasks)이 있다면, 그 때 실행에 걸린 시간을 측정하고 다음 호출을 더 일찍할지 더 늦게 할지 계획할 수 있습니다. 

