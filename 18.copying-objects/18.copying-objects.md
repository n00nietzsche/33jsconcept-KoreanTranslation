# 들어가기 전에

- 이 포스팅은 https://scotch.io/bar-talk/copying-objects-in-javascript 에 있는 포스팅들을 번역한 것입니다. 오역이나 의역이 있을 수 있습니다. 지적해주시면 확인 후 바로 정정하겠습니다.

- original source of this posting is from https://scotch.io/bar-talk/copying-objects-in-javascript If the original author requests deletion, it will be deleted immediately.

- Translated by Jake Seo (서진규)

	- https://velog.io/@jakeseo_me
	- https://github.com/n00nietzsche

> 자바스크립트 개발자라면 알아야 할 33가지 개념 #18 자바스크립트 : 오브젝트 복사하기

오브젝트는 자바스크립트의 기반이 되는 개념 중 하나입니다. 오브젝트는 기본적으로 프로퍼티들의 컬렉션입니다 그리고 프로퍼티는 키와 값의 조합입니다. 거의 대부분의 자바스크립트 오브젝트는 프로토타입 체인의 top에 위치한 `Object`의 인스턴스입니다.

# 소개(Introduction)

```js
let obj = {
  a: 1,
  b: 2,
};
let copy = obj;

obj.a = 5;
console.log(copy.a);
// Result 
// a = 5;
```

[JS Bin에서 편집해보기](https://jsbin.com/yudogil/1/edit?js,console)

`obj` 변수는 초기화되는 새로운 오브젝트를 위한 컨테이너입니다. `copy` 변수는 같은 오브젝트를 가리키고 그 오브젝트를 가리키는 레퍼런스입니다. `{ a : 1, b : 2}` 오브젝트는 "나에게 접근하는 방법은 2가지가 있지" 라고 말하는 중입니다. `obj` 변수 또는 `copy` 변수 둘 중 하나를 통해서 오브젝트에 접근할 수 있고 접근 후에 오브젝트에 변화를 주게 되면 두 방법 중 어떤 방법으로 접근했는지에 상관없이 오브젝트 자체에 변화가 일어날 것입니다.
> call by reference

불변성은 요즘 화제입니다 그리고 이러한 흐름을 반드시 알아야 합니다! 이러한 방법을 사용하지 않으면 어떠한 불변성의 형태를 제거하고 코드의 다른 부분에서 원본 오브젝트가 사용되어, 버그를 만들 수도 있습니다.

# 오브젝트를 복사하는 원시적(naive)인 방법

오브젝트를 복사하는 원시적인 방법은 원본 오브젝트의 프로퍼티를 반복하고 각 프로퍼티를 복사하는 것입니다. 예제 코드를 봅시다.

```js
function copy(mainObj) {
  let objCopy = {}; // objCopy will store a copy of the mainObj
  let key;

  for (key in mainObj) {
    objCopy[key] = mainObj[key]; // copies each property to the objCopy object
  }
  return objCopy;
}

const mainObj = {
  a: 2,
  b: 5,
  c: {
    x: 7,
    y: 4,
  },
}

console.log(copy(mainObj));
```

[JS Bin에서 편집해보기](https://jsbin.com/vukifig/edit?js,console)

## 상속 이슈

1. `objCopy`는 `mainObj` 오브젝트 프로토타입 메소드와 다른 새로운 `Object.prototype` 메소드를 갖고 있습니다. 그건 우리가 원하는 것이 아닙니다. 우리는 원본 오브젝트의 정확한 복사본을 원합니다.
2. 프로퍼티 기술자(descriptors)는 복사되지 않습니다. `false` 값으로 세팅되는 값을 가진 "작성 가능한" 기술자는 `objCopy`에서는 `true`가 될 것입니다.
3. 위의 코드에서는 `mainObj`의 `enumerable` 프로퍼티만을 복사합니다.
4. 만일 원본 오브젝트에서의 프로퍼티 중 하나가 오브젝트 그 자체라면, 그 오브젝트는 각각의 프로퍼티에서 같은 오브젝트를 참조하게 되며 복사본과 원본 사이에서 공유될 것입니다.

# 얕은(Shallow) 오브젝트 복사하기

소스 최상위 레벨 프로퍼티들이 어떠한 참조없이 복사될 때, 오브젝트는 얕게 복사된다고 합니다. 그리고 레퍼런스로 복사된 오브젝트 값을 가진 소스 프로퍼티가 존재하게 됩니다. 만일 소스 값이 오브젝트를 가리키는 레퍼런스라면, 결국 타겟 오브젝트를 가리키는 레퍼런스 값만 복사하게 됩니다.

얕은 복사는 최상위 레벨 프로퍼티들을 복사합니다. 하지만 중첩된 오브젝트들은 원본(original, source)과 복사본(copy, target)사이에서 공유됩니다.

## `Object.assign()` 메소드 사용하기

`Object.assign()` 메소드는 하나 또는 그 이상의 원본 오브젝트로부터 복사본 오브젝트로 모든 enumerable한 프로퍼티의 값을 복사하기 위해 사용됩니다. 반환 값은 물론 복사본 오브젝트입니다.

```js
let obj = {
  a: 1,
  b: 2,
};
let objCopy = Object.assign({}, obj);
console.log(objCopy);
// Result - { a: 1, b: 2 }
```
[JS Bin에서 편집해보기](https://jsbin.com/rirawav/edit?js,console)

이 메소드도 지금까지는 제 역할을 잘 하고 있네요. 우리는 `obj`의 복사본을 만들었습니다. 이제 불변성이 존재하는지 확인해봅시다.

```js
let obj = {
  a: 1,
  b: 2,
};
let objCopy = Object.assign({}, obj);

console.log(objCopy); // result - { a: 1, b: 2 }
objCopy.b = 89;
console.log(objCopy); // result - { a: 1, b: 89 }
console.log(obj); // result - { a: 1, b: 2 }
```

[JS Bin에서 편집해보기](https://jsbin.com/sugoru/edit?js,console)

위의 코드에서, 우리는 프로퍼티 `objCopy` 오브젝트 내에 존재하는 `'b'`의 값을 `89`로 바꾸고 변경된 `objCopy` 오브젝트를 콘솔에 출력해보았습니다. 변화는 오직 `objCopy` 오브젝트에만 적용됐습니다. 마지막 줄은 `obj` 오브젝트가 아직 그대로이고 변하지 않았는지 확인하는 코드입니다. 이것이 의미하는 것은 우리가 원본 오브젝트에서 참조 없이 성공적으로 오브젝트 복사에 성공했다는 것입니다.

## `Object.assign()`의 함정

우리는 성공적으로 복사본을 만들었고 모든 것들이 정상적으로 돌아갔습니다. 우리가 얕은 복사에 대해서 논의했던 것에 대해 기억하시나요? 이 예제를 봅시다.

```js
let obj = {
  a: 1,
  b: {
    c: 2,
  },
}
let newObj = Object.assign({}, obj);
console.log(newObj); // { a: 1, b: { c: 2} }

obj.a = 10;
console.log(obj); // { a: 10, b: { c: 2} }
console.log(newObj); // { a: 1, b: { c: 2} }

newObj.a = 20;
console.log(obj); // { a: 10, b: { c: 2} }
console.log(newObj); // { a: 20, b: { c: 2} }

newObj.b.c = 30;
console.log(obj); // { a: 10, b: { c: 30} }
console.log(newObj); // { a: 20, b: { c: 30} }

// Note: newObj.b.c = 30; Read why..
```

[JS Bin에서 편집해보기](https://jsbin.com/fefedoc/edit?js,console)

## 왜 obj.b.c = 30일까?

